{"ast":null,"code":"// import React from \"react\";\nimport { GRID_NODE_UNVISITED_COLOR, GRID_LINES_COLOR, BOXES_X, BOXES_Y, BOX_SIZE, GRID_NODE_SOLUTION_COLOR, NODE_LABELS, TARGET_NODE, START_NODE, GRID_START_NODE_COLOR, GRID_TARGET_NODE_COLOR } from \"./constants\";\nexport const drawGrid = (ctx, rectX, rectY) => {\n  ctx.clearRect(0, 0, window.innerWidth, window.innerHeight); // populates the grid with squares\n\n  for (let y = 0; y < BOXES_Y; y++) {\n    for (let x = 0; x < BOXES_X; x++) {\n      // add a single rect to path:\n      ctx.beginPath();\n      ctx.rect(x * BOX_SIZE, y * BOX_SIZE, BOX_SIZE, BOX_SIZE);\n      if (getNodeKey(x, y) === START_NODE) ctx.fillStyle = GRID_START_NODE_COLOR;else if (getNodeKey(x, y) === TARGET_NODE) ctx.fillStyle = GRID_TARGET_NODE_COLOR;else ctx.fillStyle = GRID_NODE_UNVISITED_COLOR;\n      ctx.fill();\n    }\n  } // draws the verticle lines\n\n\n  for (let x = 0; x <= BOXES_X; x++) {\n    ctx.beginPath();\n    ctx.moveTo(BOX_SIZE * x, 0);\n    ctx.lineTo(BOX_SIZE * x, BOXES_Y * BOX_SIZE);\n    ctx.closePath();\n    ctx.lineWidth = 0.5;\n    ctx.strokeStyle = GRID_LINES_COLOR;\n    ctx.stroke();\n  } // draws the horizontal lines\n\n\n  for (let y = 0; y <= BOXES_Y; y++) {\n    ctx.beginPath();\n    ctx.moveTo(0, BOX_SIZE * y);\n    ctx.lineTo(BOXES_X * BOX_SIZE, BOX_SIZE * y);\n    ctx.closePath();\n    ctx.lineWidth = 0.5;\n    ctx.strokeStyle = GRID_LINES_COLOR;\n    ctx.stroke();\n  }\n};\nexport const generateGridData = () => {\n  const grid = {};\n\n  for (let y = 0; y < BOXES_Y; y++) {\n    for (let x = 0; x < BOXES_X; x++) {\n      const key = getNodeKey(x, y);\n      const label = NODE_LABELS.UNVISISTED;\n      const nodes = getConnectedNodes(x, y);\n      const box = {\n        x,\n        y,\n        label,\n        nodes,\n        parent: undefined\n      };\n      grid[key] = box;\n    }\n  }\n\n  return grid;\n};\n\nconst getConnectedNodes = (x, y) => {\n  const nodes = []; // Checks if the node is on the left edge or the right edge or the middle of the grid, where middle is an x such that it is not on the left or right edge\n\n  if (x === 0) nodes.push(getNodeKey(x + 1, y));else if ((x + 1) % BOXES_X === 0) nodes.push(getNodeKey(x - 1, y));else {\n    nodes.push(getNodeKey(x + 1, y));\n    nodes.push(getNodeKey(x - 1, y));\n  } // Checks if the node is on the top edge or the bottom edge or the middle of the grid, where middle is a y such that it is not on the top or bottom edge\n\n  if (y === 0) nodes.push(getNodeKey(x, y + 1));else if (y === BOXES_Y - 1) nodes.push(getNodeKey(x, y - 1));else {\n    nodes.push(getNodeKey(x, y + 1));\n    nodes.push(getNodeKey(x, y - 1));\n  }\n  return nodes;\n};\n\nexport const getNodeKey = (x, y) => {\n  return `x${x},y${y}`;\n};\nexport const delay = ms => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\nexport const animateBoxFill = (timestamp, {\n  start,\n  previousTimestamp,\n  previousDelta,\n  ctx,\n  x,\n  y,\n  color\n}) => {\n  if (start === undefined) start = timestamp;\n  const elapsed = timestamp - start;\n  let delta = 0;\n\n  if (previousTimestamp !== timestamp) {\n    // extra computation here to make sure the boxes enlarge from the center\n    // reduce box size by 2 so we could see the grid lines\n    delta = Math.min(0.05 * elapsed, BOX_SIZE - 2);\n    ctx.fillStyle = color;\n    ctx.clearRect(x - previousDelta / 2, y - previousDelta / 2, previousDelta, previousDelta);\n    ctx.fillRect(x - delta / 2, y - delta / 2, delta, delta);\n  }\n\n  if (elapsed < 5000) {\n    previousTimestamp = timestamp;\n    const animateBoxParams = {\n      start,\n      previousTimestamp,\n      previousDelta: delta,\n      ctx,\n      x,\n      y,\n      color\n    };\n    requestAnimationFrame(timestamp => animateBoxFill(timestamp, animateBoxParams));\n  }\n};\nexport const backtrace = async (currentNode, grid, ctx) => {\n  const backTrackNodeArray = [];\n\n  while (currentNode) {\n    backTrackNodeArray.push(currentNode);\n    currentNode = grid[currentNode].parent;\n  }\n\n  for (let i = backTrackNodeArray.length - 1; i >= 0; --i) {\n    // await delay(2);\n    const x = grid[backTrackNodeArray[i]].x;\n    const y = grid[backTrackNodeArray[i]].y;\n    const animateBoxParams = {\n      start: undefined,\n      previousTimestamp: undefined,\n      previousDelta: 0,\n      ctx,\n      x: x * BOX_SIZE + BOX_SIZE / 2,\n      y: y * BOX_SIZE + BOX_SIZE / 2,\n      color: GRID_NODE_SOLUTION_COLOR\n    };\n    requestAnimationFrame(timestamp => animateBoxFill(timestamp, animateBoxParams));\n  }\n};\nexport function shuffle(array) {\n  let currentIndex = array.length,\n      randomIndex; // While there remain elements to shuffle...\n\n  while (currentIndex !== 0) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--; // And swap it with the current element.\n\n    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];\n  }\n\n  return array;\n}\nexport function getRandomInt(max) {\n  return Math.floor(Math.random() * max);\n} // export const listenForCanvasHover = (\n//   e: MouseEvent,\n//   ctx: CanvasRenderingContext2D,\n//   grid: IGrid\n// ) => {\n//   let rect = (\n//       document.querySelector(\"body\") as HTMLBodyElement\n//     ).getBoundingClientRect(),\n//     rectX = e.clientX - rect.left,\n//     rectY =\n//       e.clientY -\n//       rect.top -\n//       parseInt(\n//         window\n//           .getComputedStyle(\n//             document.querySelector(\".c-navbar\") as HTMLDivElement\n//           )\n//           .height.split(\"px\")[0]\n//       );\n//   drawGrid(ctx, grid, rectX, rectY);\n// };","map":{"version":3,"sources":["/home/anthony/Documents/projects/ancient-gps/src/components/grid/helpers.tsx"],"names":["GRID_NODE_UNVISITED_COLOR","GRID_LINES_COLOR","BOXES_X","BOXES_Y","BOX_SIZE","GRID_NODE_SOLUTION_COLOR","NODE_LABELS","TARGET_NODE","START_NODE","GRID_START_NODE_COLOR","GRID_TARGET_NODE_COLOR","drawGrid","ctx","rectX","rectY","clearRect","window","innerWidth","innerHeight","y","x","beginPath","rect","getNodeKey","fillStyle","fill","moveTo","lineTo","closePath","lineWidth","strokeStyle","stroke","generateGridData","grid","key","label","UNVISISTED","nodes","getConnectedNodes","box","parent","undefined","push","delay","ms","Promise","resolve","setTimeout","animateBoxFill","timestamp","start","previousTimestamp","previousDelta","color","elapsed","delta","Math","min","fillRect","animateBoxParams","requestAnimationFrame","backtrace","currentNode","backTrackNodeArray","i","length","shuffle","array","currentIndex","randomIndex","floor","random","getRandomInt","max"],"mappings":"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","sourcesContent":["// import React from \"react\";\nimport { IGrid, IBox, IAnimateBoxFill } from \"./types\";\nimport {\n  GRID_NODE_UNVISITED_COLOR,\n  GRID_LINES_COLOR,\n  BOXES_X,\n  BOXES_Y,\n  BOX_SIZE,\n  GRID_NODE_SOLUTION_COLOR,\n  NODE_LABELS,\n  TARGET_NODE,\n  START_NODE,\n  GRID_START_NODE_COLOR,\n  GRID_TARGET_NODE_COLOR,\n} from \"./constants\";\n\nexport const drawGrid = (\n  ctx: CanvasRenderingContext2D,\n  rectX: number,\n  rectY: number\n) => {\n  ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n\n  // populates the grid with squares\n  for (let y = 0; y < BOXES_Y; y++) {\n    for (let x = 0; x < BOXES_X; x++) {\n      // add a single rect to path:\n      ctx.beginPath();\n      ctx.rect(x * BOX_SIZE, y * BOX_SIZE, BOX_SIZE, BOX_SIZE);\n\n      if (getNodeKey(x, y) === START_NODE)\n        ctx.fillStyle = GRID_START_NODE_COLOR;\n      else if (getNodeKey(x, y) === TARGET_NODE)\n        ctx.fillStyle = GRID_TARGET_NODE_COLOR;\n      else ctx.fillStyle = GRID_NODE_UNVISITED_COLOR;\n\n      ctx.fill();\n    }\n  }\n\n  // draws the verticle lines\n  for (let x = 0; x <= BOXES_X; x++) {\n    ctx.beginPath();\n    ctx.moveTo(BOX_SIZE * x, 0);\n    ctx.lineTo(BOX_SIZE * x, BOXES_Y * BOX_SIZE);\n    ctx.closePath();\n    ctx.lineWidth = 0.5;\n    ctx.strokeStyle = GRID_LINES_COLOR;\n    ctx.stroke();\n  }\n\n  // draws the horizontal lines\n  for (let y = 0; y <= BOXES_Y; y++) {\n    ctx.beginPath();\n    ctx.moveTo(0, BOX_SIZE * y);\n    ctx.lineTo(BOXES_X * BOX_SIZE, BOX_SIZE * y);\n    ctx.closePath();\n    ctx.lineWidth = 0.5;\n    ctx.strokeStyle = GRID_LINES_COLOR;\n    ctx.stroke();\n  }\n};\n\nexport const generateGridData = (): IGrid => {\n  const grid: IGrid = {};\n\n  for (let y = 0; y < BOXES_Y; y++) {\n    for (let x = 0; x < BOXES_X; x++) {\n      const key = getNodeKey(x, y);\n      const label = NODE_LABELS.UNVISISTED;\n      const nodes = getConnectedNodes(x, y);\n      const box: IBox = {\n        x,\n        y,\n        label,\n        nodes,\n        parent: undefined,\n      };\n      grid[key] = box;\n    }\n  }\n\n  return grid;\n};\n\nconst getConnectedNodes = (x: number, y: number): string[] => {\n  const nodes: string[] = [];\n\n  // Checks if the node is on the left edge or the right edge or the middle of the grid, where middle is an x such that it is not on the left or right edge\n  if (x === 0) nodes.push(getNodeKey(x + 1, y));\n  else if ((x + 1) % BOXES_X === 0) nodes.push(getNodeKey(x - 1, y));\n  else {\n    nodes.push(getNodeKey(x + 1, y));\n    nodes.push(getNodeKey(x - 1, y));\n  }\n\n  // Checks if the node is on the top edge or the bottom edge or the middle of the grid, where middle is a y such that it is not on the top or bottom edge\n  if (y === 0) nodes.push(getNodeKey(x, y + 1));\n  else if (y === BOXES_Y - 1) nodes.push(getNodeKey(x, y - 1));\n  else {\n    nodes.push(getNodeKey(x, y + 1));\n    nodes.push(getNodeKey(x, y - 1));\n  }\n\n  return nodes;\n};\n\nexport const getNodeKey = (x: number, y: number): string => {\n  return `x${x},y${y}`;\n};\n\nexport const delay = (ms: number) => {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n};\n\nexport const animateBoxFill = (\n  timestamp: number,\n  { start, previousTimestamp, previousDelta, ctx, x, y, color }: IAnimateBoxFill\n) => {\n  if (start === undefined) start = timestamp;\n  const elapsed = timestamp - start;\n  let delta = 0;\n\n  if (previousTimestamp !== timestamp) {\n    // extra computation here to make sure the boxes enlarge from the center\n    // reduce box size by 2 so we could see the grid lines\n    delta = Math.min(0.05 * elapsed, BOX_SIZE - 2);\n    ctx.fillStyle = color;\n    ctx.clearRect(\n      x - previousDelta / 2,\n      y - previousDelta / 2,\n      previousDelta,\n      previousDelta\n    );\n    ctx.fillRect(x - delta / 2, y - delta / 2, delta, delta);\n  }\n\n  if (elapsed < 5000) {\n    previousTimestamp = timestamp;\n    const animateBoxParams: IAnimateBoxFill = {\n      start,\n      previousTimestamp,\n      previousDelta: delta,\n      ctx,\n      x,\n      y,\n      color,\n    };\n    requestAnimationFrame((timestamp) =>\n      animateBoxFill(timestamp, animateBoxParams)\n    );\n  }\n};\n\nexport const backtrace = async (\n  currentNode: string | null,\n  grid: IGrid,\n  ctx: CanvasRenderingContext2D\n) => {\n  const backTrackNodeArray = [];\n  while (currentNode) {\n    backTrackNodeArray.push(currentNode);\n    currentNode = grid[currentNode].parent as string | null;\n  }\n  for (let i = backTrackNodeArray.length - 1; i >= 0; --i) {\n    // await delay(2);\n    const x = grid[backTrackNodeArray[i]].x;\n    const y = grid[backTrackNodeArray[i]].y;\n\n    const animateBoxParams: IAnimateBoxFill = {\n      start: undefined,\n      previousTimestamp: undefined,\n      previousDelta: 0,\n      ctx,\n      x: x * BOX_SIZE + BOX_SIZE / 2,\n      y: y * BOX_SIZE + BOX_SIZE / 2,\n      color: GRID_NODE_SOLUTION_COLOR,\n    };\n\n    requestAnimationFrame((timestamp) =>\n      animateBoxFill(timestamp, animateBoxParams)\n    );\n  }\n};\n\nexport function shuffle(array: string[]) {\n  let currentIndex = array.length,\n    randomIndex;\n\n  // While there remain elements to shuffle...\n  while (currentIndex !== 0) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--;\n\n    // And swap it with the current element.\n    [array[currentIndex], array[randomIndex]] = [\n      array[randomIndex],\n      array[currentIndex],\n    ];\n  }\n\n  return array;\n}\n\nexport function getRandomInt(max: number) {\n  return Math.floor(Math.random() * max);\n}\n\n// export const listenForCanvasHover = (\n//   e: MouseEvent,\n//   ctx: CanvasRenderingContext2D,\n//   grid: IGrid\n// ) => {\n//   let rect = (\n//       document.querySelector(\"body\") as HTMLBodyElement\n//     ).getBoundingClientRect(),\n//     rectX = e.clientX - rect.left,\n//     rectY =\n//       e.clientY -\n//       rect.top -\n//       parseInt(\n//         window\n//           .getComputedStyle(\n//             document.querySelector(\".c-navbar\") as HTMLDivElement\n//           )\n//           .height.split(\"px\")[0]\n//       );\n\n//   drawGrid(ctx, grid, rectX, rectY);\n// };\n"]},"metadata":{},"sourceType":"module"}