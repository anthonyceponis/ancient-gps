{"ast":null,"code":"import { BOXES_X, BOXES_Y, BOX_SIZE, GRID_WALL_NODE_COLOR, NODE_LABELS, START_NODE, TARGET_NODE } from \"../constants\";\nimport { animateBoxFill, delay, getNodeKey } from \"../helpers\";\nexport const recursiveDivision = async ({\n  grid,\n  rowStart,\n  rowEnd,\n  colStart,\n  colEnd,\n  split,\n  surroundingWalls,\n  ctx\n}) => {\n  if (rowEnd < rowStart || colEnd < colStart) {\n    return;\n  }\n\n  if (!surroundingWalls) {\n    for (let node of Object.keys(grid)) {\n      let x = parseInt(node.split(\",\")[0].split(\"x\")[1]);\n      let y = parseInt(node.split(\",\")[1].split(\"y\")[1]);\n\n      if (x === 0 || y === 0 || x === BOXES_X - 1 || y === BOXES_Y - 1) {\n        grid[getNodeKey(x, y)].label = NODE_LABELS.WALL;\n        const animateBoxParams = {\n          start: undefined,\n          previousTimestamp: undefined,\n          previousDelta: 0,\n          ctx,\n          x: x * BOX_SIZE + BOX_SIZE / 2,\n          y: y * BOX_SIZE + BOX_SIZE / 2,\n          color: GRID_WALL_NODE_COLOR\n        };\n        await delay(1);\n        requestAnimationFrame(timestamp => animateBoxFill(timestamp, animateBoxParams));\n      }\n    }\n\n    surroundingWalls = true;\n  }\n\n  if (split === \"horizontal\") {\n    let possibleRows = [];\n\n    for (let i = rowStart; i <= rowEnd; i += 2) {\n      possibleRows.push(i);\n    }\n\n    let possibleCols = [];\n\n    for (let i = colStart - 1; i <= colEnd + 1; i += 2) {\n      possibleCols.push(i);\n    }\n\n    let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n    let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n    let currentRow = possibleRows[randomRowIndex];\n    let colRandom = possibleCols[randomColIndex];\n\n    for (let node of Object.keys(grid)) {\n      let x = parseInt(node.split(\",\")[0].split(\"x\")[1]);\n      let y = parseInt(node.split(\",\")[1].split(\"y\")[1]);\n\n      if (y === currentRow && x !== colRandom && x >= colStart - 1 && x <= colEnd + 1 && getNodeKey(x, y) !== START_NODE && getNodeKey(x, y) !== TARGET_NODE) {\n        grid[getNodeKey(x, y)].label = NODE_LABELS.WALL;\n        const animateBoxParams = {\n          start: undefined,\n          previousTimestamp: undefined,\n          previousDelta: 0,\n          ctx,\n          x: x * BOX_SIZE + BOX_SIZE / 2,\n          y: y * BOX_SIZE + BOX_SIZE / 2,\n          color: GRID_WALL_NODE_COLOR\n        };\n        await delay(1);\n        requestAnimationFrame(timestamp => animateBoxFill(timestamp, animateBoxParams));\n      }\n    }\n\n    if (currentRow - 2 - rowStart > colEnd - colStart) {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd: currentRow - 2,\n        colStart,\n        colEnd,\n        split,\n        surroundingWalls,\n        ctx\n      });\n    } else {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd: currentRow - 2,\n        colStart,\n        colEnd,\n        split: \"vertical\",\n        surroundingWalls,\n        ctx\n      });\n    }\n\n    if (rowEnd - (currentRow + 2) > colEnd - colStart) {\n      await recursiveDivision({\n        grid,\n        rowStart: currentRow + 2,\n        rowEnd,\n        colStart,\n        colEnd,\n        split,\n        surroundingWalls,\n        ctx\n      });\n    } else {\n      await recursiveDivision({\n        grid,\n        rowStart: currentRow + 2,\n        rowEnd,\n        colStart,\n        colEnd,\n        split: \"vertical\",\n        surroundingWalls,\n        ctx\n      });\n    }\n  } else {\n    let possibleCols = [];\n\n    for (let number = colStart; number <= colEnd; number += 2) {\n      possibleCols.push(number);\n    }\n\n    let possibleRows = [];\n\n    for (let number = rowStart - 1; number <= rowEnd + 1; number += 2) {\n      possibleRows.push(number);\n    }\n\n    let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n    let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n    let currentCol = possibleCols[randomColIndex];\n    let rowRandom = possibleRows[randomRowIndex];\n\n    for (let node of Object.keys(grid)) {\n      let x = parseInt(node.split(\",\")[0].split(\"x\")[1]);\n      let y = parseInt(node.split(\",\")[1].split(\"y\")[1]);\n\n      if (x === currentCol && y !== rowRandom && y >= rowStart - 1 && y <= rowEnd + 1 && getNodeKey(x, y) !== START_NODE && getNodeKey(x, y) !== TARGET_NODE) {\n        grid[getNodeKey(x, y)].label = NODE_LABELS.WALL;\n        const animateBoxParams = {\n          start: undefined,\n          previousTimestamp: undefined,\n          previousDelta: 0,\n          ctx,\n          x: x * BOX_SIZE + BOX_SIZE / 2,\n          y: y * BOX_SIZE + BOX_SIZE / 2,\n          color: GRID_WALL_NODE_COLOR\n        };\n        await delay(1);\n        requestAnimationFrame(timestamp => animateBoxFill(timestamp, animateBoxParams));\n      }\n    }\n\n    if (rowEnd - rowStart > currentCol - 2 - colStart) {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd,\n        colStart,\n        colEnd: currentCol - 2,\n        split: \"horizontal\",\n        surroundingWalls,\n        ctx\n      });\n    } else {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd,\n        colStart,\n        colEnd: currentCol - 2,\n        split,\n        surroundingWalls,\n        ctx\n      });\n    }\n\n    if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd,\n        colStart: currentCol + 2,\n        colEnd,\n        split: \"horizontal\",\n        surroundingWalls,\n        ctx\n      });\n    } else {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd,\n        colStart: currentCol + 2,\n        colEnd,\n        split,\n        surroundingWalls,\n        ctx\n      });\n    }\n  }\n};","map":{"version":3,"sources":["/home/anthony/Documents/projects/ancient-gps/src/components/grid/algorithms/recursiveDivision.ts"],"names":["BOXES_X","BOXES_Y","BOX_SIZE","GRID_WALL_NODE_COLOR","NODE_LABELS","START_NODE","TARGET_NODE","animateBoxFill","delay","getNodeKey","recursiveDivision","grid","rowStart","rowEnd","colStart","colEnd","split","surroundingWalls","ctx","node","Object","keys","x","parseInt","y","label","WALL","animateBoxParams","start","undefined","previousTimestamp","previousDelta","color","requestAnimationFrame","timestamp","possibleRows","i","push","possibleCols","randomRowIndex","Math","floor","random","length","randomColIndex","currentRow","colRandom","number","currentCol","rowRandom"],"mappings":"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","sourcesContent":["import { IGrid, IAnimateBoxFill } from \"../types\";\nimport {\n  BOXES_X,\n  BOXES_Y,\n  BOX_SIZE,\n  GRID_WALL_NODE_COLOR,\n  NODE_LABELS,\n  START_NODE,\n  TARGET_NODE,\n} from \"../constants\";\n\nimport { animateBoxFill, delay, getNodeKey } from \"../helpers\";\n\nexport const recursiveDivision = async ({\n  grid,\n  rowStart,\n  rowEnd,\n  colStart,\n  colEnd,\n  split,\n  surroundingWalls,\n  ctx,\n}: {\n  grid: IGrid;\n  rowStart: number;\n  rowEnd: number;\n  colStart: number;\n  colEnd: number;\n  split: string;\n  surroundingWalls: boolean;\n  ctx: CanvasRenderingContext2D;\n}) => {\n  if (rowEnd < rowStart || colEnd < colStart) {\n    return;\n  }\n  if (!surroundingWalls) {\n    for (let node of Object.keys(grid)) {\n      let x = parseInt(node.split(\",\")[0].split(\"x\")[1]);\n      let y = parseInt(node.split(\",\")[1].split(\"y\")[1]);\n      if (x === 0 || y === 0 || x === BOXES_X - 1 || y === BOXES_Y - 1) {\n        grid[getNodeKey(x, y)].label = NODE_LABELS.WALL;\n\n        const animateBoxParams: IAnimateBoxFill = {\n          start: undefined,\n          previousTimestamp: undefined,\n          previousDelta: 0,\n          ctx,\n          x: x * BOX_SIZE + BOX_SIZE / 2,\n          y: y * BOX_SIZE + BOX_SIZE / 2,\n          color: GRID_WALL_NODE_COLOR,\n        };\n\n        await delay(1);\n        requestAnimationFrame((timestamp) =>\n          animateBoxFill(timestamp, animateBoxParams)\n        );\n      }\n    }\n    surroundingWalls = true;\n  }\n  if (split === \"horizontal\") {\n    let possibleRows = [];\n    for (let i = rowStart; i <= rowEnd; i += 2) {\n      possibleRows.push(i);\n    }\n    let possibleCols = [];\n    for (let i = colStart - 1; i <= colEnd + 1; i += 2) {\n      possibleCols.push(i);\n    }\n    let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n    let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n    let currentRow = possibleRows[randomRowIndex];\n    let colRandom = possibleCols[randomColIndex];\n    for (let node of Object.keys(grid)) {\n      let x = parseInt(node.split(\",\")[0].split(\"x\")[1]);\n      let y = parseInt(node.split(\",\")[1].split(\"y\")[1]);\n      if (\n        y === currentRow &&\n        x !== colRandom &&\n        x >= colStart - 1 &&\n        x <= colEnd + 1 &&\n        getNodeKey(x, y) !== START_NODE &&\n        getNodeKey(x, y) !== TARGET_NODE\n      ) {\n        grid[getNodeKey(x, y)].label = NODE_LABELS.WALL;\n\n        const animateBoxParams: IAnimateBoxFill = {\n          start: undefined,\n          previousTimestamp: undefined,\n          previousDelta: 0,\n          ctx,\n          x: x * BOX_SIZE + BOX_SIZE / 2,\n          y: y * BOX_SIZE + BOX_SIZE / 2,\n          color: GRID_WALL_NODE_COLOR,\n        };\n\n        await delay(1);\n        requestAnimationFrame((timestamp) =>\n          animateBoxFill(timestamp, animateBoxParams)\n        );\n      }\n    }\n    if (currentRow - 2 - rowStart > colEnd - colStart) {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd: currentRow - 2,\n        colStart,\n        colEnd,\n        split,\n        surroundingWalls,\n        ctx,\n      });\n    } else {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd: currentRow - 2,\n        colStart,\n        colEnd,\n        split: \"vertical\",\n        surroundingWalls,\n        ctx,\n      });\n    }\n    if (rowEnd - (currentRow + 2) > colEnd - colStart) {\n      await recursiveDivision({\n        grid,\n        rowStart: currentRow + 2,\n        rowEnd,\n        colStart,\n        colEnd,\n        split,\n        surroundingWalls,\n        ctx,\n      });\n    } else {\n      await recursiveDivision({\n        grid,\n        rowStart: currentRow + 2,\n        rowEnd,\n        colStart,\n        colEnd,\n        split: \"vertical\",\n        surroundingWalls,\n        ctx,\n      });\n    }\n  } else {\n    let possibleCols = [];\n    for (let number = colStart; number <= colEnd; number += 2) {\n      possibleCols.push(number);\n    }\n    let possibleRows = [];\n    for (let number = rowStart - 1; number <= rowEnd + 1; number += 2) {\n      possibleRows.push(number);\n    }\n    let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n    let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n    let currentCol = possibleCols[randomColIndex];\n    let rowRandom = possibleRows[randomRowIndex];\n    for (let node of Object.keys(grid)) {\n      let x = parseInt(node.split(\",\")[0].split(\"x\")[1]);\n      let y = parseInt(node.split(\",\")[1].split(\"y\")[1]);\n      if (\n        x === currentCol &&\n        y !== rowRandom &&\n        y >= rowStart - 1 &&\n        y <= rowEnd + 1 &&\n        getNodeKey(x, y) !== START_NODE &&\n        getNodeKey(x, y) !== TARGET_NODE\n      ) {\n        grid[getNodeKey(x, y)].label = NODE_LABELS.WALL;\n        const animateBoxParams: IAnimateBoxFill = {\n          start: undefined,\n          previousTimestamp: undefined,\n          previousDelta: 0,\n          ctx,\n          x: x * BOX_SIZE + BOX_SIZE / 2,\n          y: y * BOX_SIZE + BOX_SIZE / 2,\n          color: GRID_WALL_NODE_COLOR,\n        };\n\n        await delay(1);\n        requestAnimationFrame((timestamp) =>\n          animateBoxFill(timestamp, animateBoxParams)\n        );\n      }\n    }\n    if (rowEnd - rowStart > currentCol - 2 - colStart) {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd,\n        colStart,\n        colEnd: currentCol - 2,\n        split: \"horizontal\",\n        surroundingWalls,\n        ctx,\n      });\n    } else {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd,\n        colStart,\n        colEnd: currentCol - 2,\n        split,\n        surroundingWalls,\n        ctx,\n      });\n    }\n    if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd,\n        colStart: currentCol + 2,\n        colEnd,\n        split: \"horizontal\",\n        surroundingWalls,\n        ctx,\n      });\n    } else {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd,\n        colStart: currentCol + 2,\n        colEnd,\n        split,\n        surroundingWalls,\n        ctx,\n      });\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"module"}