{"ast":null,"code":"import { BOX_SIZE, GRID_NODE_VISITED_COLOR, NODE_LABELS, START_NODE, TARGET_NODE } from \"../constants\";\nimport { animateBoxFill, delay, backtrace } from \"../helpers\";\nexport const bfs = async (start, grid, ctx) => {\n  const queue = [start];\n  const visited = new Set();\n\n  while (queue.length > 0) {\n    // delay to make the animation more visually pleasing\n    await delay(10);\n    const front = queue[0];\n    const x = grid[front].x;\n    const y = grid[front].y;\n\n    if (front !== START_NODE && front !== TARGET_NODE) {\n      const animateBoxParams = {\n        start: undefined,\n        previousTimestamp: undefined,\n        previousDelta: 0,\n        ctx,\n        x: x * BOX_SIZE + BOX_SIZE / 2,\n        y: y * BOX_SIZE + BOX_SIZE / 2,\n        color: GRID_NODE_VISITED_COLOR\n      };\n      requestAnimationFrame(timestamp => animateBoxFill(timestamp, animateBoxParams));\n    }\n\n    if (front === TARGET_NODE) {\n      grid[START_NODE].parent = null;\n      return backtrace(front, grid, ctx);\n    }\n\n    for (const node of grid[front].nodes) if (!visited.has(node) && grid[node].label !== NODE_LABELS.WALL) {\n      queue.push(node);\n      visited.add(node); // add the parent so we could then backtrace to visualise the shortest path\n\n      grid[node].parent = front;\n    }\n\n    queue.shift();\n  }\n\n  console.log(\"does not exist m8!\");\n};","map":{"version":3,"sources":["/home/anthony/Documents/projects/ancient-gps/src/components/grid/algorithms/bfs.ts"],"names":["BOX_SIZE","GRID_NODE_VISITED_COLOR","NODE_LABELS","START_NODE","TARGET_NODE","animateBoxFill","delay","backtrace","bfs","start","grid","ctx","queue","visited","Set","length","front","x","y","animateBoxParams","undefined","previousTimestamp","previousDelta","color","requestAnimationFrame","timestamp","parent","node","nodes","has","label","WALL","push","add","shift","console","log"],"mappings":"AACA,SACEA,QADF,EAEEC,uBAFF,EAGEC,WAHF,EAIEC,UAJF,EAKEC,WALF,QAMO,cANP;AAQA,SAASC,cAAT,EAAyBC,KAAzB,EAAgCC,SAAhC,QAAiD,YAAjD;AAEA,OAAO,MAAMC,GAAG,GAAG,OACjBC,KADiB,EAEjBC,IAFiB,EAGjBC,GAHiB,KAId;AACH,QAAMC,KAAK,GAAG,CAACH,KAAD,CAAd;AACA,QAAMI,OAAO,GAAG,IAAIC,GAAJ,EAAhB;;AAEA,SAAOF,KAAK,CAACG,MAAN,GAAe,CAAtB,EAAyB;AACvB;AACA,UAAMT,KAAK,CAAC,EAAD,CAAX;AACA,UAAMU,KAAK,GAAGJ,KAAK,CAAC,CAAD,CAAnB;AACA,UAAMK,CAAC,GAAGP,IAAI,CAACM,KAAD,CAAJ,CAAYC,CAAtB;AACA,UAAMC,CAAC,GAAGR,IAAI,CAACM,KAAD,CAAJ,CAAYE,CAAtB;;AAEA,QAAIF,KAAK,KAAKb,UAAV,IAAwBa,KAAK,KAAKZ,WAAtC,EAAmD;AACjD,YAAMe,gBAAiC,GAAG;AACxCV,QAAAA,KAAK,EAAEW,SADiC;AAExCC,QAAAA,iBAAiB,EAAED,SAFqB;AAGxCE,QAAAA,aAAa,EAAE,CAHyB;AAIxCX,QAAAA,GAJwC;AAKxCM,QAAAA,CAAC,EAAEA,CAAC,GAAGjB,QAAJ,GAAeA,QAAQ,GAAG,CALW;AAMxCkB,QAAAA,CAAC,EAAEA,CAAC,GAAGlB,QAAJ,GAAeA,QAAQ,GAAG,CANW;AAOxCuB,QAAAA,KAAK,EAAEtB;AAPiC,OAA1C;AAUAuB,MAAAA,qBAAqB,CAAEC,SAAD,IACpBpB,cAAc,CAACoB,SAAD,EAAYN,gBAAZ,CADK,CAArB;AAGD;;AAED,QAAIH,KAAK,KAAKZ,WAAd,EAA2B;AACzBM,MAAAA,IAAI,CAACP,UAAD,CAAJ,CAAiBuB,MAAjB,GAA0B,IAA1B;AACA,aAAOnB,SAAS,CAACS,KAAD,EAAQN,IAAR,EAAcC,GAAd,CAAhB;AACD;;AAED,SAAK,MAAMgB,IAAX,IAAmBjB,IAAI,CAACM,KAAD,CAAJ,CAAYY,KAA/B,EACE,IAAI,CAACf,OAAO,CAACgB,GAAR,CAAYF,IAAZ,CAAD,IAAsBjB,IAAI,CAACiB,IAAD,CAAJ,CAAWG,KAAX,KAAqB5B,WAAW,CAAC6B,IAA3D,EAAiE;AAC/DnB,MAAAA,KAAK,CAACoB,IAAN,CAAWL,IAAX;AACAd,MAAAA,OAAO,CAACoB,GAAR,CAAYN,IAAZ,EAF+D,CAG/D;;AACAjB,MAAAA,IAAI,CAACiB,IAAD,CAAJ,CAAWD,MAAX,GAAoBV,KAApB;AACD;;AAEHJ,IAAAA,KAAK,CAACsB,KAAN;AACD;;AACDC,EAAAA,OAAO,CAACC,GAAR,CAAY,oBAAZ;AACD,CA/CM","sourcesContent":["import { IGrid, IAnimateBoxFill } from \"../types\";\nimport {\n  BOX_SIZE,\n  GRID_NODE_VISITED_COLOR,\n  NODE_LABELS,\n  START_NODE,\n  TARGET_NODE,\n} from \"../constants\";\n\nimport { animateBoxFill, delay, backtrace } from \"../helpers\";\n\nexport const bfs = async (\n  start: string,\n  grid: IGrid,\n  ctx: CanvasRenderingContext2D\n) => {\n  const queue = [start];\n  const visited = new Set();\n\n  while (queue.length > 0) {\n    // delay to make the animation more visually pleasing\n    await delay(10);\n    const front = queue[0];\n    const x = grid[front].x;\n    const y = grid[front].y;\n\n    if (front !== START_NODE && front !== TARGET_NODE) {\n      const animateBoxParams: IAnimateBoxFill = {\n        start: undefined,\n        previousTimestamp: undefined,\n        previousDelta: 0,\n        ctx,\n        x: x * BOX_SIZE + BOX_SIZE / 2,\n        y: y * BOX_SIZE + BOX_SIZE / 2,\n        color: GRID_NODE_VISITED_COLOR,\n      };\n\n      requestAnimationFrame((timestamp) =>\n        animateBoxFill(timestamp, animateBoxParams)\n      );\n    }\n\n    if (front === TARGET_NODE) {\n      grid[START_NODE].parent = null;\n      return backtrace(front, grid, ctx);\n    }\n\n    for (const node of grid[front].nodes)\n      if (!visited.has(node) && grid[node].label !== NODE_LABELS.WALL) {\n        queue.push(node);\n        visited.add(node);\n        // add the parent so we could then backtrace to visualise the shortest path\n        grid[node].parent = front;\n      }\n\n    queue.shift();\n  }\n  console.log(\"does not exist m8!\");\n};\n"]},"metadata":{},"sourceType":"module"}