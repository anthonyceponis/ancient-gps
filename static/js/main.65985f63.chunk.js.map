{"version":3,"sources":["components/navbar/constants.ts","components/grid/constants.ts","images/bullSand.svg","components/navbar/actions.ts","images/bullBlack.svg","images/theseus.svg","components/grid/helpers.tsx","components/app/constants.ts","components/app/actions.ts","components/secondaryNav/index.tsx","components/secondaryNav/constants.ts","components/sidenav/index.tsx","components/navbar/index.tsx","components/grid/searchAlgorithms/bfs.ts","components/grid/searchAlgorithms/dfs.ts","components/grid/mazeAlgorithms/recursiveDivision.ts","components/grid/mazeAlgorithms/stairPattern.ts","components/grid/index.tsx","components/app/index.tsx","components/app/reducer.ts","components/navbar/reducer.ts","reducers/index.ts","store.ts","index.tsx"],"names":["BLOCK_NAVBAR","BLOCK_SIDENAV","SET_ALGORITHM","SET_MAZE","SET_SPEED","ALGORITHM_BFS","ALGORITHM_DFS","MAZE_RECURSIVE_DIVISION","MAZE_STAIR","TOGGLE_VISUALISING_ALGORITHM","TOGGLE_VISUALISING_MAZE","algorithm","localStorage","getItem","maze","speed","toString","NODE_LABELS","initialState","parseInt","visualisingAlgorithm","visualisingMaze","setAlgorithm","dispatch","setItem","type","payload","setMaze","setSpeed","toggleVisualisingAlgorithm","toggleVisualisingMaze","GRID_LINES_COLOR","GRID_NODE_UNVISITED_COLOR","GRID_NODE_VISITED_COLOR","GRID_NODE_SOLUTION_COLOR","GRID_WALL_NODE_COLOR","BOX_SIZE","BOXES_X","Math","floor","window","innerWidth","BOXES_Y","innerHeight","getNodeKey","x","y","START_NODE","TARGET_NODE","drawGrid","ctx","Infinity","wall","clearRect","beginPath","rect","fillStyle","fill","base_image","Image","src","Bull","onload","drawImage","Theseus","moveTo","lineTo","closePath","lineWidth","strokeStyle","stroke","generateGridData","grid","key","box","label","UNVISISTED","nodes","getConnectedNodes","parent","undefined","weight","push","delay","ms","Promise","resolve","setTimeout","animateBoxFill","timestamp","start","previousTimestamp","previousDelta","color","elapsed","delta","min","fillRect","animateBoxParams","requestAnimationFrame","backtrace","currentNode","a","backTrackNodeArray","i","length","UPDATE_GRID_DATA","gridData","updateGridData","SecondaryNav","className","style","backgroundColor","alt","SideNav","open","setOpen","useSelector","Navbar","useDispatch","onClick","useState","pointerEvents","bfs","queue","visited","Set","front","node","has","WALL","add","shift","console","log","dfs","reverse","recursiveDivision","rowStart","rowEnd","colStart","colEnd","split","surroundingWalls","Object","keys","possibleRows","possibleCols","randomRowIndex","random","randomColIndex","currentRow","colRandom","number","currentCol","rowRandom","stairPattern","height","stairUp","Grid","canvasRef","useRef","store","App","setCtx","useEffect","current","canvas","width","getContext","addEventListener","e","document","querySelector","getBoundingClientRect","scaleX","scaleY","coordinates","clientX","left","clientY","top","shiftKey","ctrlKey","currentNodeKey","listenForCanvasHover","listenForCanvasClick","then","ref","reducer","state","action","rootReducer","combineReducers","AppReducer","NavReducer","enhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","createStore","applyMiddleware","thunk","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.65985f63.chunk.js","sourcesContent":["import { INavStore } from \"./types\";\n\nexport const BLOCK_NAVBAR = \"c-navbar\";\nexport const BLOCK_SIDENAV = \"c-sidenav\";\n\nexport const SET_ALGORITHM = \"SET_ALGORITHM\";\nexport const SET_MAZE = \"SET_MAZE\";\nexport const SET_SPEED = \"SET_SPEED\";\n\nexport const ALGORITHM_BFS = \"ALGORITHM_BFS\";\nexport const ALGORITHM_DFS = \"ALGORITHM_DFS\";\nexport const ALGORITHM_DIJIKSTRAS = \"ALGORITHM_DIJIKSTRAS\";\nexport const ALGORITHMA_STAR = \"ALGORITHMA_STAR\";\n\nexport const MAZE_RECURSIVE_DIVISION = \"MAZE_RECURSIVE_DIVISION\";\nexport const MAZE_STAIR = \"MAZE_STAIR\";\n\nexport const SPEED_FAST = 1;\nexport const SPEED_MODERATE = 10;\nexport const SPEED_SLOW = 30;\n\nexport const TOGGLE_VISUALISING_ALGORITHM = \"TOGGLE_VISUALISING_ALGORITHM\";\nexport const TOGGLE_VISUALISING_MAZE = \"TOGGLE_VISUALISING_MAZE\";\n\nlet algorithm = localStorage.getItem(\"algorithm\");\nif (algorithm === \"\") algorithm = null;\nlet maze = localStorage.getItem(\"maze\");\nif (maze === \"\") maze = null;\nlet speed: string | null = localStorage.getItem(\"speed\");\nif (speed === null) speed = SPEED_MODERATE.toString();\n\nexport const initialState: INavStore = {\n  algorithm: algorithm,\n  maze: maze,\n  speed: parseInt(speed),\n  visualisingAlgorithm: false,\n  visualisingMaze: false,\n};\n","export const BLOCK_GRID = \"c-grid\";\n\nexport const GRID_LINES_COLOR = \"#192734\";\nexport const GRID_NODE_UNVISITED_COLOR = \"#081419\";\nexport const GRID_NODE_VISITED_COLOR = \"#B0AEB1\";\nexport const GRID_NODE_SOLUTION_COLOR = \"white\";\nexport const GRID_START_NODE_COLOR = \"white\";\nexport const GRID_TARGET_NODE_COLOR = \"white\";\nexport const GRID_WALL_NODE_COLOR = \"#f4a460\";\n\nexport const BOX_SIZE = 26;\nexport const BOXES_X = Math.floor(window.innerWidth / BOX_SIZE);\nexport const BOXES_Y = Math.floor((window.innerHeight - 75) / BOX_SIZE);\n\n// Had to declare again to avoid init error\nconst getNodeKey = (x: number, y: number): string => {\n  return `x${x},y${y}`;\n};\n\nexport const START_NODE = getNodeKey(5, Math.floor(BOXES_Y / 2));\nexport const TARGET_NODE = getNodeKey(BOXES_X - 5, Math.floor(BOXES_Y / 2));\n\nexport enum NODE_LABELS {\n  UNVISISTED,\n  VISITED,\n  WALL,\n}\n","export default __webpack_public_path__ + \"static/media/bullSand.9e8ce4e1.svg\";","import { Dispatch } from \"redux\";\nimport {\n  SET_ALGORITHM,\n  SET_MAZE,\n  SET_SPEED,\n  TOGGLE_VISUALISING_ALGORITHM,\n  TOGGLE_VISUALISING_MAZE,\n} from \"./constants\";\n\nexport const setAlgorithm =\n  (algorithm: string | null) => (dispatch: Dispatch) => {\n    localStorage.setItem(\"algorithm\", algorithm === null ? \"\" : algorithm);\n    dispatch({ type: SET_ALGORITHM, payload: algorithm });\n  };\n\nexport const setMaze = (maze: string | null) => (dispatch: Dispatch) => {\n  localStorage.setItem(\"maze\", maze === null ? \"\" : maze);\n  dispatch({ type: SET_MAZE, payload: maze });\n};\n\nexport const setSpeed = (speed: number) => (dispatch: Dispatch) => {\n  localStorage.setItem(\"speed\", speed.toString());\n  dispatch({ type: SET_SPEED, payload: speed });\n};\n\nexport const toggleVisualisingAlgorithm = () => (dispatch: Dispatch) => {\n  dispatch({ type: TOGGLE_VISUALISING_ALGORITHM, payload: null });\n};\n\nexport const toggleVisualisingMaze = () => (dispatch: Dispatch) => {\n  dispatch({ type: TOGGLE_VISUALISING_MAZE, payload: null });\n};\n","export default __webpack_public_path__ + \"static/media/bullBlack.fc79a5a7.svg\";","export default __webpack_public_path__ + \"static/media/theseus.c0bd10a4.svg\";","// import React from \"react\";\nimport { IGrid, IBox, IAnimateBoxFill } from \"./types\";\nimport {\n  GRID_NODE_UNVISITED_COLOR,\n  GRID_LINES_COLOR,\n  BOXES_X,\n  BOXES_Y,\n  BOX_SIZE,\n  GRID_NODE_SOLUTION_COLOR,\n  NODE_LABELS,\n  TARGET_NODE,\n  START_NODE,\n  GRID_START_NODE_COLOR,\n  GRID_TARGET_NODE_COLOR,\n  GRID_WALL_NODE_COLOR,\n} from \"./constants\";\n\nimport Bull from \"../../images/bullBlack.svg\";\nimport Theseus from \"../../images/theseus.svg\";\n\nexport const drawGrid = ({\n  ctx,\n  x = Infinity,\n  y = Infinity,\n  wall = null,\n}: {\n  ctx: CanvasRenderingContext2D;\n  x?: number;\n  y?: number;\n  wall?: boolean | null;\n}) => {\n  if (x !== Infinity) {\n    if (wall !== null) {\n      ctx.beginPath();\n      ctx.rect(x + 1, y + 1, BOX_SIZE - 2, BOX_SIZE - 2);\n      ctx.fillStyle = wall ? GRID_WALL_NODE_COLOR : GRID_NODE_UNVISITED_COLOR;\n      ctx.fill();\n    }\n    return;\n  }\n\n  ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n\n  // populates the grid with squares\n  for (let y = 0; y < BOXES_Y; y++) {\n    for (let x = 0; x < BOXES_X; x++) {\n      // add a single rect to path:\n      ctx.beginPath();\n      ctx.rect(x * BOX_SIZE, y * BOX_SIZE, BOX_SIZE, BOX_SIZE);\n\n      if (getNodeKey(x, y) === START_NODE) {\n        ctx.fillStyle = GRID_START_NODE_COLOR;\n        ctx.fill();\n        const base_image = new Image();\n        base_image.src = Bull;\n        base_image.onload = function () {\n          ctx.drawImage(\n            base_image,\n            x * BOX_SIZE,\n            y * BOX_SIZE,\n            BOX_SIZE,\n            BOX_SIZE\n          );\n        };\n      } else if (getNodeKey(x, y) === TARGET_NODE) {\n        ctx.fillStyle = GRID_TARGET_NODE_COLOR;\n        ctx.fill();\n        const base_image = new Image();\n        base_image.src = Theseus;\n        base_image.onload = function () {\n          ctx.drawImage(\n            base_image,\n            x * BOX_SIZE,\n            y * BOX_SIZE,\n            BOX_SIZE,\n            BOX_SIZE\n          );\n        };\n      } else {\n        ctx.fillStyle = GRID_NODE_UNVISITED_COLOR;\n        ctx.fill();\n      }\n    }\n  }\n\n  // draws the verticle lines\n  for (let x = 0; x <= BOXES_X; x++) {\n    ctx.beginPath();\n    ctx.moveTo(BOX_SIZE * x, 0);\n    ctx.lineTo(BOX_SIZE * x, BOXES_Y * BOX_SIZE);\n    ctx.closePath();\n    ctx.lineWidth = 0.5;\n    ctx.strokeStyle = GRID_LINES_COLOR;\n    ctx.stroke();\n  }\n\n  // draws the horizontal lines\n  for (let y = 0; y <= BOXES_Y; y++) {\n    ctx.beginPath();\n    ctx.moveTo(0, BOX_SIZE * y);\n    ctx.lineTo(BOXES_X * BOX_SIZE, BOX_SIZE * y);\n    ctx.closePath();\n    ctx.lineWidth = 0.5;\n    ctx.strokeStyle = GRID_LINES_COLOR;\n    ctx.stroke();\n  }\n};\n\nexport const generateGridData = (): IGrid => {\n  const grid: IGrid = {};\n\n  for (let y = 0; y < BOXES_Y; y++) {\n    for (let x = 0; x < BOXES_X; x++) {\n      const key = getNodeKey(x, y);\n      const label = NODE_LABELS.UNVISISTED;\n      const nodes = getConnectedNodes(x, y);\n      const box: IBox = {\n        x,\n        y,\n        label,\n        nodes,\n        parent: undefined,\n        weight: 0,\n      };\n      grid[key] = box;\n    }\n  }\n\n  return grid;\n};\n\nconst getConnectedNodes = (x: number, y: number): string[] => {\n  const nodes: string[] = [];\n\n  // Checks if the node is on the left edge or the right edge or the middle of the grid, where middle is an x such that it is not on the left or right edge\n  if (x === 0) nodes.push(getNodeKey(x + 1, y));\n  else if ((x + 1) % BOXES_X === 0) nodes.push(getNodeKey(x - 1, y));\n  else {\n    nodes.push(getNodeKey(x + 1, y));\n    nodes.push(getNodeKey(x - 1, y));\n  }\n\n  // Checks if the node is on the top edge or the bottom edge or the middle of the grid, where middle is a y such that it is not on the top or bottom edge\n  if (y === 0) nodes.push(getNodeKey(x, y + 1));\n  else if (y === BOXES_Y - 1) nodes.push(getNodeKey(x, y - 1));\n  else {\n    nodes.push(getNodeKey(x, y + 1));\n    nodes.push(getNodeKey(x, y - 1));\n  }\n\n  return nodes;\n};\n\nexport const getNodeKey = (x: number, y: number): string => {\n  return `x${x},y${y}`;\n};\n\nexport const delay = (ms: number) => {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n};\n\nexport const animateBoxFill = (\n  speed: number,\n  timestamp: number,\n  { start, previousTimestamp, previousDelta, ctx, x, y, color }: IAnimateBoxFill\n) => {\n  if (start === undefined) start = timestamp;\n  const elapsed = timestamp - start;\n  let delta = 0;\n\n  if (previousTimestamp !== timestamp) {\n    // extra computation here to make sure the boxes enlarge from the center\n    // reduce box size by 2 so we could see the grid lines\n    delta = Math.min(0.05 * elapsed, BOX_SIZE - 2);\n    ctx.fillStyle = color;\n    ctx.clearRect(\n      x - previousDelta / 2,\n      y - previousDelta / 2,\n      previousDelta,\n      previousDelta\n    );\n    ctx.fillRect(x - delta / 2, y - delta / 2, delta, delta);\n  }\n\n  if (elapsed < speed * 1000) {\n    previousTimestamp = timestamp;\n    const animateBoxParams: IAnimateBoxFill = {\n      start,\n      previousTimestamp,\n      previousDelta: delta,\n      ctx,\n      x,\n      y,\n      color,\n    };\n    requestAnimationFrame((timestamp) =>\n      animateBoxFill(speed, timestamp, animateBoxParams)\n    );\n  }\n};\n\nexport const backtrace = async (\n  currentNode: string | null,\n  grid: IGrid,\n  speed: number,\n  ctx: CanvasRenderingContext2D\n) => {\n  const backTrackNodeArray = [];\n  while (currentNode) {\n    backTrackNodeArray.push(currentNode);\n    currentNode = grid[currentNode].parent as string | null;\n  }\n  for (let i = backTrackNodeArray.length - 1; i >= 0; --i) {\n    await delay(speed);\n    const x = grid[backTrackNodeArray[i]].x;\n    const y = grid[backTrackNodeArray[i]].y;\n\n    if (getNodeKey(x, y) !== START_NODE && getNodeKey(x, y) !== TARGET_NODE) {\n      const animateBoxParams: IAnimateBoxFill = {\n        start: undefined,\n        previousTimestamp: undefined,\n        previousDelta: 0,\n        ctx,\n        x: x * BOX_SIZE + BOX_SIZE / 2,\n        y: y * BOX_SIZE + BOX_SIZE / 2,\n        color: GRID_NODE_SOLUTION_COLOR,\n      };\n\n      requestAnimationFrame((timestamp) =>\n        animateBoxFill(speed, timestamp, animateBoxParams)\n      );\n    }\n  }\n};\n\nexport function shuffle(array: string[]) {\n  let currentIndex = array.length,\n    randomIndex;\n\n  // While there remain elements to shuffle...\n  while (currentIndex !== 0) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--;\n\n    // And swap it with the current element.\n    [array[currentIndex], array[randomIndex]] = [\n      array[randomIndex],\n      array[currentIndex],\n    ];\n  }\n\n  return array;\n}\n\nexport function getRandomInt(max: number) {\n  return Math.floor(Math.random() * max);\n}\n\nexport const listenForCanvasHover = (\n  e: MouseEvent,\n  ctx: CanvasRenderingContext2D,\n  grid: IGrid\n) => {\n  const canvas = document.querySelector(\"canvas\") as HTMLCanvasElement;\n\n  var rect = canvas.getBoundingClientRect(), // abs. size of element\n    scaleX = canvas.width / rect.width, // relationship bitmap vs. element for X\n    scaleY = canvas.height / rect.height; // relationship bitmap vs. element for Y\n\n  const coordinates = {\n    x:\n      (e.clientX - rect.left) * scaleX -\n      (((e.clientX - rect.left) * scaleX) % BOX_SIZE),\n    y:\n      (e.clientY - rect.top) * scaleY -\n      (((e.clientY - rect.top) * scaleY) % BOX_SIZE),\n  };\n\n  let wall = null;\n  if (e.shiftKey) wall = true;\n  else if (e.ctrlKey) wall = false;\n\n  if (wall !== null && grid) {\n    const currentNodeKey = getNodeKey(\n      coordinates.x / BOX_SIZE,\n      coordinates.y / BOX_SIZE\n    );\n    if (currentNodeKey === START_NODE || currentNodeKey === TARGET_NODE) return;\n    grid[currentNodeKey].label = wall\n      ? NODE_LABELS.WALL\n      : NODE_LABELS.UNVISISTED;\n  }\n\n  drawGrid({ ctx, x: coordinates.x, y: coordinates.y, wall });\n};\n\nexport const listenForCanvasClick = (\n  e: MouseEvent,\n  ctx: CanvasRenderingContext2D,\n  grid: IGrid\n) => {\n  const canvas = document.querySelector(\"canvas\") as HTMLCanvasElement;\n\n  var rect = canvas.getBoundingClientRect(), // abs. size of element\n    scaleX = canvas.width / rect.width, // relationship bitmap vs. element for X\n    scaleY = canvas.height / rect.height; // relationship bitmap vs. element for Y\n\n  const coordinates = {\n    x:\n      (e.clientX - rect.left) * scaleX -\n      (((e.clientX - rect.left) * scaleX) % BOX_SIZE),\n    y:\n      (e.clientY - rect.top) * scaleY -\n      (((e.clientY - rect.top) * scaleY) % BOX_SIZE),\n  };\n\n  let wall = null;\n\n  if (grid) {\n    const currentNodeKey = getNodeKey(\n      coordinates.x / BOX_SIZE,\n      coordinates.y / BOX_SIZE\n    );\n    if (currentNodeKey === START_NODE || currentNodeKey === TARGET_NODE) return;\n    wall = grid[currentNodeKey].label === NODE_LABELS.UNVISISTED;\n    grid[currentNodeKey].label = wall\n      ? NODE_LABELS.WALL\n      : NODE_LABELS.UNVISISTED;\n  }\n\n  drawGrid({ ctx, x: coordinates.x, y: coordinates.y, wall });\n};\n","import { IAppStore } from \"./types\";\nimport { generateGridData } from \"..//grid/helpers\";\n\nexport const UPDATE_GRID_DATA = \"UPDATE_GRID_DATA\";\n\nexport const initialState: IAppStore = {\n  gridData: generateGridData(),\n};\n","import { Dispatch } from \"redux\";\nimport { UPDATE_GRID_DATA } from \"./constants\";\nimport { IGrid } from \"../grid/types\";\n\nexport const updateGridData = (grid: IGrid) => (dispatch: Dispatch) => {\n  dispatch({ type: UPDATE_GRID_DATA, payload: grid });\n};\n","import React from \"react\";\nimport { BLOCK_SECONDARY_NAV } from \"./constants\";\n\nimport {\n  GRID_NODE_UNVISITED_COLOR,\n  GRID_NODE_VISITED_COLOR,\n  GRID_WALL_NODE_COLOR,\n  GRID_NODE_SOLUTION_COLOR,\n} from \"../grid/constants\";\n\nimport Bull from \"../../images/bullBlack.svg\";\nimport Theseus from \"../../images/theseus.svg\";\n\nconst SecondaryNav: React.FC = () => {\n  return (\n    <div className={`${BLOCK_SECONDARY_NAV}`}>\n      <div>\n        <b>Key:</b>\n      </div>\n      <div>\n        <div style={{ backgroundColor: GRID_NODE_UNVISITED_COLOR }} /> Unvisited\n        Node\n      </div>\n      <div>\n        <div style={{ backgroundColor: GRID_NODE_VISITED_COLOR }} /> Visited\n        Node\n      </div>\n      <div>\n        <div style={{ backgroundColor: GRID_WALL_NODE_COLOR }} /> Wall Node\n      </div>\n      <div>\n        <div style={{ backgroundColor: GRID_NODE_SOLUTION_COLOR }} />\n        Solution Node\n      </div>\n      <div>\n        <div style={{ backgroundColor: GRID_NODE_SOLUTION_COLOR }}>\n          <img src={Bull} alt=\"Bull icon\" />\n        </div>\n        Start Node (Minotaur)\n      </div>\n      <div>\n        <div style={{ backgroundColor: GRID_NODE_SOLUTION_COLOR }}>\n          <img src={Theseus} alt=\"Theseus icon\" />\n        </div>\n        Target Node (Theseus)\n      </div>\n    </div>\n  );\n};\n\nexport default SecondaryNav;\n","export const BLOCK_SECONDARY_NAV = \"c-secondary-nav\";\n","import React from \"react\";\nimport {\n  ALGORITHM_BFS,\n  ALGORITHM_DFS,\n  BLOCK_SIDENAV,\n  MAZE_RECURSIVE_DIVISION,\n  SPEED_MODERATE,\n  SPEED_FAST,\n  SPEED_SLOW,\n  MAZE_STAIR,\n} from \"../navbar/constants\";\nimport Bull from \"../../images/bullSand.svg\";\nimport {\n  setAlgorithm,\n  setMaze,\n  setSpeed,\n  toggleVisualisingAlgorithm,\n  toggleVisualisingMaze,\n} from \"../navbar/actions\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { IStore } from \"../../types\";\nimport { updateGridData } from \"../app/actions\";\nimport { generateGridData } from \"../grid/helpers\";\nimport SecondaryNav from \"../secondaryNav\";\n\nexport const SideNav: React.FC<{\n  open: boolean;\n  setOpen: React.Dispatch<boolean>;\n}> = ({\n  open,\n  setOpen,\n}: {\n  open: boolean;\n  setOpen: React.Dispatch<boolean>;\n}) => {\n  const speed = useSelector(({ Navbar }: IStore) => Navbar.speed);\n\n  const dispatch = useDispatch();\n\n  return (\n    <div>\n      <div\n        className={`${BLOCK_SIDENAV} ${\n          open === true ? BLOCK_SIDENAV + \"-open\" : BLOCK_SIDENAV + \"-closed\"\n        }`}\n      >\n        <div>\n          <img src={Bull} alt=\"Bull Logo\" />\n          <ul>\n            <li>\n              <b>Searching Algorithms</b>\n              <ul>\n                <li>\n                  <span\n                    className={`${BLOCK_SIDENAV}-hover`}\n                    onClick={() => {\n                      dispatch(toggleVisualisingAlgorithm());\n                      dispatch(setAlgorithm(ALGORITHM_BFS));\n                      setOpen(false);\n                    }}\n                  >\n                    Breadth-first search\n                  </span>\n                </li>\n                <li>\n                  <span\n                    className={`${BLOCK_SIDENAV}-hover`}\n                    onClick={() => {\n                      dispatch(toggleVisualisingAlgorithm());\n                      dispatch(setAlgorithm(ALGORITHM_DFS));\n                      setOpen(false);\n                    }}\n                  >\n                    Depth-first search\n                  </span>\n                </li>\n              </ul>\n            </li>\n            <li>\n              <b>Maze Generators</b>\n              <ul>\n                <li>\n                  <span\n                    className={`${BLOCK_SIDENAV}-hover`}\n                    onClick={() => {\n                      dispatch(setMaze(null));\n                      dispatch(updateGridData(generateGridData()));\n                    }}\n                  >\n                    No Maze\n                  </span>\n                </li>\n                <li>\n                  <span\n                    className={`${BLOCK_SIDENAV}-hover`}\n                    onClick={() => {\n                      dispatch(toggleVisualisingMaze());\n                      dispatch(setAlgorithm(null));\n                      dispatch(updateGridData(generateGridData()));\n                      dispatch(setMaze(MAZE_RECURSIVE_DIVISION));\n                      setOpen(false);\n                    }}\n                  >\n                    Recursive Division\n                  </span>\n                </li>\n                <li>\n                  <span\n                    className={`${BLOCK_SIDENAV}-hover`}\n                    onClick={() => {\n                      dispatch(toggleVisualisingMaze());\n                      dispatch(setAlgorithm(null));\n                      dispatch(updateGridData(generateGridData()));\n                      dispatch(setMaze(MAZE_STAIR));\n                      setOpen(false);\n                    }}\n                  >\n                    Stair Pattern\n                  </span>\n                </li>\n                <li>\n                  <b>Add wall: </b> <br /> hover + shiftKey\n                </li>\n                <li>\n                  <b>Remove wall: </b>\n                  <br /> hover + ctrlKey\n                </li>\n                <li>\n                  <b>Toggle wall: </b>\n                  <br /> click\n                </li>\n              </ul>\n            </li>\n            <li>\n              <b>Speed</b>\n              <ul>\n                <li>\n                  <span\n                    className={`${BLOCK_SIDENAV}-hover ${\n                      speed === SPEED_FAST ? BLOCK_SIDENAV + \"-active\" : \"\"\n                    }`}\n                    onClick={() => dispatch(setSpeed(SPEED_FAST))}\n                  >\n                    Fast\n                  </span>\n                </li>\n                <li>\n                  <span\n                    className={`${BLOCK_SIDENAV}-hover ${\n                      speed === SPEED_MODERATE ? BLOCK_SIDENAV + \"-active\" : \"\"\n                    }`}\n                    onClick={() => dispatch(setSpeed(SPEED_MODERATE))}\n                  >\n                    Moderate\n                  </span>\n                </li>\n                <li>\n                  <span\n                    className={`${BLOCK_SIDENAV}-hover ${\n                      speed === SPEED_SLOW ? BLOCK_SIDENAV + \"-active\" : \"\"\n                    }`}\n                    onClick={() => dispatch(setSpeed(SPEED_SLOW))}\n                  >\n                    Slow\n                  </span>\n                </li>\n              </ul>\n            </li>\n            <li>\n              <span\n                className={`${BLOCK_SIDENAV}-hover `}\n                onClick={() => {\n                  dispatch(updateGridData(generateGridData()));\n                }}\n              >\n                Clear Board\n              </span>\n            </li>\n          </ul>\n        </div>\n        <SecondaryNav />\n      </div>\n    </div>\n  );\n};\n","import React, { useState } from \"react\";\nimport { useSelector } from \"react-redux\";\nimport { IStore } from \"../../types\";\nimport { BLOCK_NAVBAR } from \"./constants\";\nimport { SideNav } from \"../sidenav/index\";\n\nconst Navbar: React.FC = () => {\n  const [open, setOpen] = useState<boolean>(false);\n  const visualisingAlgorithm = useSelector(\n    ({ Navbar }: IStore) => Navbar.visualisingAlgorithm\n  );\n  const visualisingMaze = useSelector(\n    ({ Navbar }: IStore) => Navbar.visualisingMaze\n  );\n\n  return (\n    <div className={BLOCK_NAVBAR}>\n      <div>\n        <h1>Ancient GPS</h1>\n      </div>\n      <div className={`${BLOCK_NAVBAR}-hamburger`}>\n        <div\n          className={`${BLOCK_NAVBAR}-hamburger-${\n            open ? \"open\" : \"closed\"\n          } ${BLOCK_NAVBAR}-hamburger-${\n            visualisingAlgorithm || visualisingMaze ? \"visualising\" : \"\"\n          }`}\n        />\n        <span\n          className={`${BLOCK_NAVBAR}-hamburger-clicker`}\n          style={{\n            pointerEvents:\n              visualisingAlgorithm || visualisingMaze ? \"none\" : \"auto\",\n          }}\n          onClick={() => {\n            if ((!open && !visualisingAlgorithm) || visualisingMaze)\n              setOpen(true);\n            else if (open) setOpen(false);\n          }}\n        ></span>\n      </div>\n      <SideNav open={open} setOpen={setOpen} />\n    </div>\n  );\n};\n\nexport default Navbar;\n","import { IGrid, IAnimateBoxFill } from \"../types\";\nimport {\n  BOX_SIZE,\n  GRID_NODE_VISITED_COLOR,\n  NODE_LABELS,\n  START_NODE,\n  TARGET_NODE,\n} from \"../constants\";\n\nimport { animateBoxFill, delay, backtrace } from \"../helpers\";\n\nexport const bfs = async (\n  start: string,\n  grid: IGrid,\n  speed: number,\n  ctx: CanvasRenderingContext2D\n) => {\n  const queue = [start];\n  const visited = new Set();\n\n  while (queue.length > 0) {\n    // delay to make the animation more visually pleasing\n    await delay(speed);\n    const front = queue[0];\n    const x = grid[front].x;\n    const y = grid[front].y;\n\n    if (front !== START_NODE && front !== TARGET_NODE) {\n      const animateBoxParams: IAnimateBoxFill = {\n        start: undefined,\n        previousTimestamp: undefined,\n        previousDelta: 0,\n        ctx,\n        x: x * BOX_SIZE + BOX_SIZE / 2,\n        y: y * BOX_SIZE + BOX_SIZE / 2,\n        color: GRID_NODE_VISITED_COLOR,\n      };\n\n      requestAnimationFrame((timestamp) =>\n        animateBoxFill(speed, timestamp, animateBoxParams)\n      );\n    }\n\n    if (front === TARGET_NODE) {\n      grid[START_NODE].parent = null;\n      return backtrace(front, grid, speed, ctx);\n    }\n\n    for (const node of grid[front].nodes)\n      if (!visited.has(node) && grid[node].label !== NODE_LABELS.WALL) {\n        queue.push(node);\n        visited.add(node);\n        // add the parent so we could then backtrace to visualise the shortest path\n        grid[node].parent = front;\n      }\n\n    queue.shift();\n  }\n  console.log(\"does not exist m8!\");\n};\n","import { IGrid, IAnimateBoxFill } from \"../types\";\nimport {\n  BOX_SIZE,\n  GRID_NODE_VISITED_COLOR,\n  START_NODE,\n  TARGET_NODE,\n  NODE_LABELS,\n} from \"../constants\";\n\nimport { animateBoxFill, delay, backtrace } from \"../helpers\";\n\nexport const dfs = async (\n  currentNode: string,\n  grid: IGrid,\n  ctx: CanvasRenderingContext2D,\n  speed: number,\n  visited: Set<string>\n): Promise<boolean> => {\n  if (currentNode === TARGET_NODE) {\n    grid[START_NODE].parent = null;\n    await backtrace(currentNode, grid, speed, ctx);\n    return true;\n  } else if (\n    grid[currentNode].nodes.length === 0 ||\n    grid[currentNode].label === NODE_LABELS.WALL\n  )\n    return false;\n\n  visited.add(currentNode);\n\n  const x = grid[currentNode].x;\n  const y = grid[currentNode].y;\n\n  if (currentNode !== START_NODE && currentNode !== TARGET_NODE) {\n    const animateBoxParams: IAnimateBoxFill = {\n      start: undefined,\n      previousTimestamp: undefined,\n      previousDelta: 0,\n      ctx,\n      x: x * BOX_SIZE + BOX_SIZE / 2,\n      y: y * BOX_SIZE + BOX_SIZE / 2,\n      color: GRID_NODE_VISITED_COLOR,\n    };\n\n    await delay(speed);\n    requestAnimationFrame((timestamp) =>\n      animateBoxFill(speed, timestamp, animateBoxParams)\n    );\n  }\n\n  for (let node of grid[currentNode].nodes.reverse()) {\n    if (!visited.has(node) && grid[node].label !== NODE_LABELS.WALL) {\n      grid[node].parent = currentNode;\n      const found = await dfs(node, grid, ctx, speed, visited);\n      if (found) return true;\n    }\n  }\n  return false;\n};\n","import { IGrid, IAnimateBoxFill } from \"../types\";\nimport {\n  BOXES_X,\n  BOXES_Y,\n  BOX_SIZE,\n  GRID_WALL_NODE_COLOR,\n  NODE_LABELS,\n  START_NODE,\n  TARGET_NODE,\n} from \"../constants\";\n\nimport { animateBoxFill, delay, getNodeKey } from \"../helpers\";\n\nexport const recursiveDivision = async ({\n  grid,\n  rowStart,\n  rowEnd,\n  colStart,\n  colEnd,\n  split,\n  surroundingWalls,\n  speed,\n  ctx,\n}: {\n  grid: IGrid;\n  rowStart: number;\n  rowEnd: number;\n  colStart: number;\n  colEnd: number;\n  split: string;\n  surroundingWalls: boolean;\n  speed: number;\n  ctx: CanvasRenderingContext2D;\n}) => {\n  if (rowEnd < rowStart || colEnd < colStart) {\n    return;\n  }\n  if (!surroundingWalls) {\n    for (let node of Object.keys(grid)) {\n      let x = parseInt(node.split(\",\")[0].split(\"x\")[1]);\n      let y = parseInt(node.split(\",\")[1].split(\"y\")[1]);\n      if (x === 0 || y === 0 || x === BOXES_X - 1 || y === BOXES_Y - 1) {\n        grid[getNodeKey(x, y)].label = NODE_LABELS.WALL;\n\n        const animateBoxParams: IAnimateBoxFill = {\n          start: undefined,\n          previousTimestamp: undefined,\n          previousDelta: 0,\n          ctx,\n          x: x * BOX_SIZE + BOX_SIZE / 2,\n          y: y * BOX_SIZE + BOX_SIZE / 2,\n          color: GRID_WALL_NODE_COLOR,\n        };\n\n        await delay(speed);\n        requestAnimationFrame((timestamp) =>\n          animateBoxFill(speed, timestamp, animateBoxParams)\n        );\n      }\n    }\n    surroundingWalls = true;\n  }\n  if (split === \"horizontal\") {\n    let possibleRows = [];\n    for (let i = rowStart; i <= rowEnd; i += 2) {\n      possibleRows.push(i);\n    }\n    let possibleCols = [];\n    for (let i = colStart - 1; i <= colEnd + 1; i += 2) {\n      possibleCols.push(i);\n    }\n    let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n    let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n    let currentRow = possibleRows[randomRowIndex];\n    let colRandom = possibleCols[randomColIndex];\n    for (let node of Object.keys(grid)) {\n      let x = parseInt(node.split(\",\")[0].split(\"x\")[1]);\n      let y = parseInt(node.split(\",\")[1].split(\"y\")[1]);\n      if (\n        y === currentRow &&\n        x !== colRandom &&\n        x >= colStart - 1 &&\n        x <= colEnd + 1 &&\n        getNodeKey(x, y) !== START_NODE &&\n        getNodeKey(x, y) !== TARGET_NODE\n      ) {\n        grid[getNodeKey(x, y)].label = NODE_LABELS.WALL;\n\n        const animateBoxParams: IAnimateBoxFill = {\n          start: undefined,\n          previousTimestamp: undefined,\n          previousDelta: 0,\n          ctx,\n          x: x * BOX_SIZE + BOX_SIZE / 2,\n          y: y * BOX_SIZE + BOX_SIZE / 2,\n          color: GRID_WALL_NODE_COLOR,\n        };\n\n        await delay(speed);\n        requestAnimationFrame((timestamp) =>\n          animateBoxFill(speed, timestamp, animateBoxParams)\n        );\n      }\n    }\n    if (currentRow - 2 - rowStart > colEnd - colStart) {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd: currentRow - 2,\n        colStart,\n        colEnd,\n        split,\n        surroundingWalls,\n        speed,\n        ctx,\n      });\n    } else {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd: currentRow - 2,\n        colStart,\n        colEnd,\n        split: \"vertical\",\n        surroundingWalls,\n        speed,\n        ctx,\n      });\n    }\n    if (rowEnd - (currentRow + 2) > colEnd - colStart) {\n      await recursiveDivision({\n        grid,\n        rowStart: currentRow + 2,\n        rowEnd,\n        colStart,\n        colEnd,\n        split,\n        surroundingWalls,\n        speed,\n        ctx,\n      });\n    } else {\n      await recursiveDivision({\n        grid,\n        rowStart: currentRow + 2,\n        rowEnd,\n        colStart,\n        colEnd,\n        split: \"vertical\",\n        surroundingWalls,\n        speed,\n        ctx,\n      });\n    }\n  } else {\n    let possibleCols = [];\n    for (let number = colStart; number <= colEnd; number += 2) {\n      possibleCols.push(number);\n    }\n    let possibleRows = [];\n    for (let number = rowStart - 1; number <= rowEnd + 1; number += 2) {\n      possibleRows.push(number);\n    }\n    let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n    let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n    let currentCol = possibleCols[randomColIndex];\n    let rowRandom = possibleRows[randomRowIndex];\n    for (let node of Object.keys(grid)) {\n      let x = parseInt(node.split(\",\")[0].split(\"x\")[1]);\n      let y = parseInt(node.split(\",\")[1].split(\"y\")[1]);\n      if (\n        x === currentCol &&\n        y !== rowRandom &&\n        y >= rowStart - 1 &&\n        y <= rowEnd + 1 &&\n        getNodeKey(x, y) !== START_NODE &&\n        getNodeKey(x, y) !== TARGET_NODE\n      ) {\n        grid[getNodeKey(x, y)].label = NODE_LABELS.WALL;\n        const animateBoxParams: IAnimateBoxFill = {\n          start: undefined,\n          previousTimestamp: undefined,\n          previousDelta: 0,\n          ctx,\n          x: x * BOX_SIZE + BOX_SIZE / 2,\n          y: y * BOX_SIZE + BOX_SIZE / 2,\n          color: GRID_WALL_NODE_COLOR,\n        };\n\n        await delay(speed);\n        requestAnimationFrame((timestamp) =>\n          animateBoxFill(speed, timestamp, animateBoxParams)\n        );\n      }\n    }\n    if (rowEnd - rowStart > currentCol - 2 - colStart) {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd,\n        colStart,\n        colEnd: currentCol - 2,\n        split: \"horizontal\",\n        surroundingWalls,\n        speed,\n        ctx,\n      });\n    } else {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd,\n        colStart,\n        colEnd: currentCol - 2,\n        split,\n        surroundingWalls,\n        speed,\n        ctx,\n      });\n    }\n    if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd,\n        colStart: currentCol + 2,\n        colEnd,\n        split: \"horizontal\",\n        surroundingWalls,\n        speed,\n        ctx,\n      });\n    } else {\n      await recursiveDivision({\n        grid,\n        rowStart,\n        rowEnd,\n        colStart: currentCol + 2,\n        colEnd,\n        split,\n        surroundingWalls,\n        speed,\n        ctx,\n      });\n    }\n  }\n};\n","import { IGrid, IAnimateBoxFill } from \"../types\";\nimport {\n  BOXES_X,\n  BOXES_Y,\n  BOX_SIZE,\n  GRID_WALL_NODE_COLOR,\n  NODE_LABELS,\n  START_NODE,\n  TARGET_NODE,\n} from \"../constants\";\n\nimport { animateBoxFill, delay, getNodeKey } from \"../helpers\";\n\nexport const stairPattern = async ({\n  grid,\n  speed,\n  ctx,\n}: {\n  grid: IGrid;\n  speed: number;\n  ctx: CanvasRenderingContext2D;\n}) => {\n  let height = BOXES_Y - 2;\n  let stairUp = true;\n  for (let i = 1; i < BOXES_X - 1; i++) {\n    if (height < 1) {\n      stairUp = !stairUp;\n      height += 1;\n    } else if (height > BOXES_Y - 2) {\n      stairUp = !stairUp;\n      height -= 1;\n    }\n    let x = i;\n    let y = height;\n    console.log(x, y, getNodeKey(x, y));\n    if (getNodeKey(x, y) !== START_NODE && getNodeKey(x, y) !== TARGET_NODE) {\n      grid[getNodeKey(x, y)].label = NODE_LABELS.WALL;\n      const animateBoxParams: IAnimateBoxFill = {\n        start: undefined,\n        previousTimestamp: undefined,\n        previousDelta: 0,\n        ctx,\n        x: x * BOX_SIZE + BOX_SIZE / 2,\n        y: y * BOX_SIZE + BOX_SIZE / 2,\n        color: GRID_WALL_NODE_COLOR,\n      };\n\n      await delay(speed);\n      requestAnimationFrame((timestamp) =>\n        animateBoxFill(speed, timestamp, animateBoxParams)\n      );\n    }\n\n    if (stairUp) height--;\n    else height++;\n  }\n};\n\nexport default stairPattern;\n","import React, { useEffect, useRef, useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { IStore } from \"../../types\";\n\nimport {\n  BLOCK_GRID,\n  BOXES_X,\n  BOXES_Y,\n  BOX_SIZE,\n  START_NODE,\n} from \"./constants\";\nimport {\n  drawGrid,\n  listenForCanvasClick,\n  listenForCanvasHover,\n} from \"./helpers\";\nimport { IGrid } from \"./types\";\nimport { bfs } from \"./searchAlgorithms/bfs\";\nimport { dfs } from \"./searchAlgorithms/dfs\";\nimport { recursiveDivision } from \"./mazeAlgorithms/recursiveDivision\";\nimport {\n  ALGORITHM_BFS,\n  ALGORITHM_DFS,\n  MAZE_RECURSIVE_DIVISION,\n  MAZE_STAIR,\n} from \"../navbar/constants\";\nimport {\n  toggleVisualisingAlgorithm,\n  toggleVisualisingMaze,\n} from \"../navbar/actions\";\nimport stairPattern from \"./mazeAlgorithms/stairPattern\";\n\nconst Grid: React.FC = () => {\n  const canvasRef = useRef(null);\n  const gridData: IGrid = useSelector((store: IStore) => store.App.gridData);\n\n  const algorithm = useSelector(({ Navbar }: IStore) => Navbar.algorithm);\n  const maze = useSelector(({ Navbar }: IStore) => Navbar.maze);\n  const speed = useSelector(({ Navbar }: IStore) => Navbar.speed);\n  const [ctx, setCtx] = useState<CanvasRenderingContext2D | null>(null);\n  const visualisingAlgorithm = useSelector(\n    ({ Navbar }: IStore) => Navbar.visualisingAlgorithm\n  );\n  const visualisingMaze = useSelector(\n    ({ Navbar }: IStore) => Navbar.visualisingMaze\n  );\n\n  const dispatch = useDispatch();\n\n  // Listens for clearing the board\n  useEffect(() => {\n    if (ctx) drawGrid({ ctx });\n  }, [gridData, ctx]);\n\n  useEffect(() => {\n    if (canvasRef.current === null) return;\n    const canvas: HTMLCanvasElement = canvasRef.current;\n    canvas.width = BOXES_X * BOX_SIZE;\n    canvas.height = BOXES_Y * BOX_SIZE;\n\n    const ctx: CanvasRenderingContext2D = canvas.getContext(\n      \"2d\"\n    ) as CanvasRenderingContext2D;\n\n    drawGrid({ ctx });\n\n    setCtx(ctx);\n\n    if (gridData)\n      canvas.addEventListener(\"mousemove\", (e) => {\n        listenForCanvasHover(e, ctx, gridData);\n      });\n    canvas.addEventListener(\"click\", (e) => {\n      listenForCanvasClick(e, ctx, gridData);\n    });\n  }, [gridData]);\n\n  useEffect(() => {\n    if (ctx === null || !visualisingAlgorithm) return;\n\n    switch (algorithm) {\n      case ALGORITHM_BFS: {\n        bfs(START_NODE, gridData, speed, ctx).then(() =>\n          dispatch(toggleVisualisingAlgorithm())\n        );\n        break;\n      }\n      case ALGORITHM_DFS: {\n        dfs(START_NODE, gridData, ctx, speed, new Set<string>()).then(() =>\n          dispatch(toggleVisualisingAlgorithm())\n        );\n        break;\n      }\n      default:\n        break;\n    }\n  }, [algorithm, maze, dispatch, gridData, speed, visualisingAlgorithm, ctx]);\n\n  useEffect(() => {\n    if (ctx === null || !visualisingMaze) return;\n\n    switch (maze) {\n      case MAZE_RECURSIVE_DIVISION: {\n        recursiveDivision({\n          grid: gridData,\n          rowStart: 2,\n          rowEnd: BOXES_Y - 3,\n          colStart: 2,\n          colEnd: BOXES_X - 3,\n          split: \"horizontal\",\n          surroundingWalls: false,\n          speed,\n          ctx,\n        }).then(() => dispatch(toggleVisualisingMaze()));\n        break;\n      }\n      case MAZE_STAIR: {\n        stairPattern({ grid: gridData, speed, ctx }).then(() =>\n          dispatch(toggleVisualisingMaze())\n        );\n        break;\n      }\n      default:\n        break;\n    }\n  }, [algorithm, maze, dispatch, gridData, speed, visualisingMaze, ctx]);\n\n  return <canvas className={`${BLOCK_GRID}`} ref={canvasRef} />;\n};\n\nexport default Grid;\n","import React from \"react\";\nimport Navbar from \"../navbar/index\";\nimport Grid from \"../grid/index\";\n\nconst App: React.FC = () => {\n  return (\n    <div>\n      <Navbar />\n      <Grid />\n    </div>\n  );\n};\n\nexport default App;\n","import { AnyAction } from \"redux\";\nimport { initialState, UPDATE_GRID_DATA } from \"./constants\";\n\nconst reducer = (state = initialState, action: AnyAction) => {\n  switch (action.type) {\n    case UPDATE_GRID_DATA: {\n      return { ...state, gridData: action.payload };\n    }\n\n    default:\n      return { ...state };\n  }\n};\n\nexport default reducer;\n","import { AnyAction } from \"redux\";\nimport {\n  initialState,\n  SET_ALGORITHM,\n  SET_MAZE,\n  SET_SPEED,\n  TOGGLE_VISUALISING_ALGORITHM,\n  TOGGLE_VISUALISING_MAZE,\n} from \"./constants\";\n\nconst reducer = (state = initialState, action: AnyAction) => {\n  switch (action.type) {\n    case SET_ALGORITHM: {\n      return { ...state, algorithm: action.payload };\n    }\n    case SET_MAZE: {\n      return { ...state, maze: action.payload };\n    }\n    case SET_SPEED: {\n      return { ...state, speed: action.payload };\n    }\n    case TOGGLE_VISUALISING_ALGORITHM: {\n      return { ...state, visualisingAlgorithm: !state.visualisingAlgorithm };\n    }\n    case TOGGLE_VISUALISING_MAZE: {\n      return { ...state, visualisingMaze: !state.visualisingMaze };\n    }\n    default:\n      return state;\n  }\n};\n\nexport default reducer;\n","import { combineReducers } from \"redux\";\nimport AppReducer from \"../components/app/reducer\";\nimport NavReducer from \"../components/navbar/reducer\";\n\nconst rootReducer = combineReducers({\n  App: AppReducer,\n  Navbar: NavReducer,\n});\n\nexport default rootReducer;\n","import { createStore, compose, applyMiddleware } from \"redux\";\nimport thunk from \"redux-thunk\";\n\nimport rootReducer from \"./reducers/index\";\n\nconst enhancers =\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\n\nexport default createStore(rootReducer, enhancers(applyMiddleware(thunk)));\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./styles/styles.scss\";\nimport App from \"./components/app/index\";\nimport { Provider } from \"react-redux\";\nimport store from \"./store\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}